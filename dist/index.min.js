import*as THREE from"https://unpkg.com/three@0.159.0/build/three.module.js";function renderGradientMesh(t,e){const o=t.colors;const n=transformColors(o,t.width);const r=new Grid(t.width,t.height);for(let t=0;t<r.width;t++){for(let e=0;e<r.height;e++){let o=new ControlPoint;o.location=[lerp(t/(r.width-1),-1,1),lerp(e/(r.height-1),-1,1)];o.uTangent[0]=2/(r.width-1);o.vTangent[1]=2/(r.height-1);r.set(t,e,o)}}for(let e=0;e<t.width;e++){for(let o=0;o<t.height;o++){r.get(e,o).location=transformPoints(t.points[e+o*t.width]);r.get(e,o).color=hex2float(n[e+o*t.width])}}const{dpoints:i,dcolors:l}=subdivideGrid(r);const s=buildGeometry(i,l);const c=new THREE.MeshBasicMaterial({color:16777215,vertexColors:true,wireframe:false});const h=new THREE.Mesh(s,c);const a=new THREE.WebGLRenderer({alpha:true,canvas:e,antialias:true});a.inputEncoding=THREE.sRGBEncoding;a.outputColorSpace=THREE.SRGBColorSpace;const f=new THREE.Scene;const u=new THREE.OrthographicCamera(-1,1,1,-1,.1,1e3);u.position.z=5;f.clear();f.add(h);a.render(f,u)}function transformPoints(t){return[lerp(t[0]/1,-1,1),lerp(t[1]/1,-1,1)]}function transformColors(t,e){const o=[];for(let n=0;n<e;n++){const r=t.slice(n*e,(n+1)*e);o.unshift(...r)}return o}class ControlPoint{color=[0,0,0];location=[0,0];uTangent=[0,0];vTangent=[0,0]}class Grid{elements=[];width=0;height=0;constructor(t,e){this.elements=new Array(t*e);this.height=e;this.width=t}get(t,e){return this.elements[t+e*this.width]}set(t,e,o){this.elements[t+e*this.width]=o}foreach(t){for(let e=0;e<this.width;e++){for(let o=0;o<this.height;o++){t(this.elements[e+o*this.width],e,o)}}}}function hex2float(t){const e=new THREE.Color(t);e.convertSRGBToLinear();return e.toArray()}function lerp(t,e,o){return e+t*(o-e)}function meshCoefficients(t,e,o,n,r){const i=t=>t.location[r];const l=t=>t.uTangent[r];const s=t=>t.vTangent[r];let c=new THREE.Matrix4;c.set(i(t),i(e),s(t),s(e),i(o),i(n),s(o),s(n),l(t),l(e),0,0,l(o),l(n),0,0);return c}function colorCoefficients(t,e,o,n,r){const i=t=>t.color[r];let l=new THREE.Matrix4;l.set(i(t),i(e),0,0,i(o),i(n),0,0,0,0,0,0,0,0,0,0);return l}const M_h=new THREE.Matrix4;M_h.set(2,-2,1,1,-3,3,-2,-1,0,0,1,0,1,0,0,0);const M_hT=M_h.clone().transpose();function surfacePoint(t,e,o,n){let r=new THREE.Vector4(t*t*t,t*t,t,1);let i=new THREE.Vector4(t*t*t,t*t,t,1);let l=new THREE.Vector4(e*e*e,e*e,e,1);let s=o.clone().transpose().premultiply(M_h).multiply(M_hT);r.applyMatrix4(s);const c=l.dot(r);let h=n.clone().transpose().premultiply(M_h).multiply(M_hT);i.applyMatrix4(h);const a=l.dot(i);return[c,a,0]}function colorPoint(t,e,o,n,r){let i=new THREE.Vector4(t*t*t,t*t,t,1);let l=new THREE.Vector4(t*t*t,t*t,t,1);let s=new THREE.Vector4(t*t*t,t*t,t,1);let c=new THREE.Vector4(e*e*e,e*e,e,1);let h=o.clone().transpose().premultiply(M_h).multiply(M_hT);i.applyMatrix4(h);const a=c.dot(i);let f=n.clone().transpose().premultiply(M_h).multiply(M_hT);l.applyMatrix4(f);const u=c.dot(l);let d=r.clone().transpose().premultiply(M_h).multiply(M_hT);s.applyMatrix4(d);const p=c.dot(s);return[a,u,p]}function buildGeometry(t,e){let o=[];let n=[];for(let e=0;e<t.width-1;e++){for(let n=0;n<t.height-1;n++){o=o.concat([...t.get(e,n),...t.get(e+1,n),...t.get(e+1,n+1),...t.get(e+1,n+1),...t.get(e,n+1),...t.get(e,n)])}}if(e){for(let o=0;o<t.width-1;o++){for(let r=0;r<t.height-1;r++){n=n.concat([...e.get(o,r),...e.get(o+1,r),...e.get(o+1,r+1),...e.get(o+1,r+1),...e.get(o,r+1),...e.get(o,r)])}}}const r=new THREE.BufferGeometry;r.setAttribute("position",new THREE.BufferAttribute(new Float32Array(o),3));r.setAttribute("color",new THREE.BufferAttribute(new Float32Array(n),3));return r}function subdivideGrid(t){let e=15;let o=new Grid((t.width-1)*e,(t.height-1)*e);let n=new Grid((t.width-1)*e,(t.height-1)*e);for(let r=0;r<t.width-1;r++){for(let i=0;i<t.height-1;i++){let l=t.get(r,i);let s=t.get(r,i+1);let c=t.get(r+1,i);let h=t.get(r+1,i+1);let a=meshCoefficients(l,s,c,h,0);let f=meshCoefficients(l,s,c,h,1);let u=colorCoefficients(l,s,c,h,0);let d=colorCoefficients(l,s,c,h,1);let p=colorCoefficients(l,s,c,h,2);for(let t=0;t<e;t++){for(let l=0;l<e;l++){o.set(r*e+t,i*e+l,surfacePoint(t/(e-1),l/(e-1),a,f));n.set(r*e+t,i*e+l,colorPoint(t/(e-1),l/(e-1),u,d,p))}}}}return{dpoints:o,dcolors:n}}export{renderGradientMesh};